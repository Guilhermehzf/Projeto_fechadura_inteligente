EEPROMHandler.cpp
#include "EEPROMHandler.h"
#include <EEPROM.h>
#include "secrets.h"

const int EEPROM_START_ADDR = 0;
const int EEPROM_SIZE = 64;
const String SENHA_PADRAO = PASSWORD;
const int TAMANHO_MAX_SENHA = 10;

void setupEeprom() {
    EEPROM.begin(EEPROM_SIZE);
}

String lerSenhaDaEeprom() {
    String senha = "";
    for (int i = 0; i < TAMANHO_MAX_SENHA; i++) {
        char c = EEPROM.read(EEPROM_START_ADDR + i);
        if (c == '\0' || c == 0xFF) { // Terminador nulo ou byte vazio
            break;
        }
        senha += c;
    }
    return senha.length() > 0 ? senha : SENHA_PADRAO;
}

void salvarSenhaNaEeprom(const String& senha) {
    unsigned int i = 0;
    for (i = 0; i < senha.length() && i < TAMANHO_MAX_SENHA; i++) {
        EEPROM.write(EEPROM_START_ADDR + i, senha[i]);
    }
    // Adiciona o terminador nulo para marcar o fim da string
    EEPROM.write(EEPROM_START_ADDR + i, '\0'); 
    EEPROM.commit();
}

EEPROMHandler.h
#ifndef EEPROM_HANDLER_H
#define EEPROM_HANDLER_H

#include <Arduino.h>

void setupEeprom();
String lerSenhaDaEeprom();
void salvarSenhaNaEeprom(const String& senha);

#endif

KeypadHandler.cpp
#include "KeypadHandler.h"
#include <Keypad.h>
#include "Log.h"

const byte ROWS = 4;
const byte COLS = 3;

char keys[ROWS][COLS] = {
  {'1','2','3'},
  {'4','5','6'},
  {'7','8','9'},
  {'*','0','#'}
};

// üîß TROQUE a ordem das colunas: era {16, 4, 2}
byte rowPins[ROWS] = {19, 18, 5, 17};
byte colPins[COLS] = { 33, 32, 25};  // ‚Üê invertido (da esquerda p/ direita)

Keypad kp = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

char lerTecla() {
  char k = kp.getKey();
  if (k) LOGF("[KEYPAD] key='%c'\n", k); // debug
  return k;
}

KeypadHandler.h
#ifndef KEYPADHANDLER_H
#define KEYPADHANDLER_H

char lerTecla();

#endif

LCDInterface.cpp
#include "LCDInterface.h"
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

static bool mostrandoMensagemTemporaria = false;
static unsigned long tempoInicioMensagem = 3000; // 3S
static const long TIMEOUT_MENSAGEM = 5000; // 5s

static void clearLine(uint8_t row) {
  lcd.setCursor(0, row);
  for (int i = 0; i < 16; i++) lcd.print(' ');
  lcd.setCursor(0, row);
}

void setupLcd() {
  lcd.init();
  lcd.backlight();
}

void exibirMensagemInicial() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Digite a senha:");
  clearLine(1); // linha de digita√ß√£o come√ßa limpa
}

void exibirDigitacaoNormal(const String& buffer) {
  // m√°scara **** na segunda linha
  lcd.setCursor(0, 1);
  clearLine(1);
  uint8_t n = buffer.length();
  if (n > 16) n = 16;
  for (uint8_t i = 0; i < n; i++) lcd.print('*');
}

void exibirModoProgramacao(const String& bufferNovaSenha) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Modo programacao");
  lcd.setCursor(0, 1);
  lcd.print("Nova: ");
  uint8_t n = bufferNovaSenha.length();
  if (n > 10) n = 10; // limite visual
  for (uint8_t i = 0; i < n; i++) lcd.print('*');
}

void exibirAcessoLiberado() {
  lcd.clear();
  lcd.print("Acesso liberado");
  mostrandoMensagemTemporaria = true;
  tempoInicioMensagem = millis();
}

void exibirTrancado() {
  lcd.clear();
  lcd.print("Trancado");
  mostrandoMensagemTemporaria = true;
  tempoInicioMensagem = millis();
}

void verificarTimeoutMensagem() {
  if (mostrandoMensagemTemporaria && (millis() - tempoInicioMensagem >= TIMEOUT_MENSAGEM)) {
    exibirMensagemInicial();
    mostrandoMensagemTemporaria = false;
  }
}

bool lcdEstaMostrandoMensagem() {
  return mostrandoMensagemTemporaria;
}

LCDInterface.h
#ifndef LCD_INTERFACE_H
#define LCD_INTERFACE_H

#include <Arduino.h>

void setupLcd();
void exibirMensagemInicial();
void exibirModoProgramacao(const String& bufferNovaSenha);
void exibirAcessoLiberado();
void exibirTrancado();
void verificarTimeoutMensagem();
bool lcdEstaMostrandoMensagem();

// mostra na 2¬™ linha a senha digitada no modo normal, mascarada com '*'
void exibirDigitacaoNormal(const String& buffer);

// opcional: telinha de boot com infos r√°pidas
void exibirInfoRede(const char* broker, int port, int relayPin);

#endif

LedControl.cpp
#include "LedControl.h"
#include <Arduino.h>

void setupLeds() {
  pinMode(RELAY_PIN, OUTPUT);
  // estado inicial: ABERTO = LOW
  digitalWrite(RELAY_PIN, LOW);
}

void atualizarLeds(bool trancaAberta) {
  // LOW = aberto; HIGH = trancado
  digitalWrite(RELAY_PIN, trancaAberta ? LOW : HIGH);
}

LedControl.h
#ifndef LED_CONTROL_H
#define LED_CONTROL_H

// Pino do rel√© (ajuste se necess√°rio)
#ifndef RELAY_PIN
#define RELAY_PIN 26
#endif

// Inicializa o pino do rel√©.
void setupLeds();

// Atualiza o rel√© com base no estado da tranca.
// true = aberto (HIGH), false = trancado (LOW).
void atualizarLeds(bool trancaAberta);

#endif

LockControl.cpp
#include "LockControl.h"
#include "LedControl.h"
#include "LCDInterface.h"
#include "MqttHandler.h"   // publish_current_state()

bool trancaAberta = true;

static void render_lock()
{
  // LEDs e LCD
  atualizarLeds(trancaAberta);
  if (trancaAberta) {
    exibirAcessoLiberado();
  } else {
    exibirTrancado();
  }
}

void lock_init(bool abertaInicial)
{
  trancaAberta = abertaInicial;

  // Garante controle do rel√©
  pinMode(RELAY_PIN, OUTPUT);

  render_lock();
}

void lock_apply(bool aberta, const char* /*method*/)
{
  trancaAberta = aberta;
  render_lock();

  // publica se estiver conectado (ou marca pendente)
  publish_current_state();
}

void lock_toggle(const char* /*method*/)
{
  lock_apply(!trancaAberta);
}

LockControl.h
#ifndef LOCKCONTROL_H
#define LOCKCONTROL_H

#include <Arduino.h>

// Estado global exposto (usado pelo MQTT/Password)
extern bool trancaAberta;

// Pino do rel√©/fechadura (ajuste se necess√°rio para seu hardware)
#ifndef RELAY_PIN
#define RELAY_PIN 26
#endif

// Inicializa estado e hardware (LED, LCD e rel√©)
void lock_init(bool abertaInicial);

// Aplica estado (atualiza LED, LCD, rel√©) e publica no MQTT
void lock_apply(bool aberta, const char* method = "local");

// Alterna o estado atual
void lock_toggle(const char* method = "local");

#endif

Log.cpp
#include "Log.h"
TeeLogger LOG;

Log.h
#pragma once
#include <Arduino.h>   // Print, size_t
#include <stdarg.h>    // va_list, va_start, va_end
#include <stdio.h>     // ::vsnprintf

class TeeLogger : public Print {
public:
  TeeLogger() : a(nullptr), b(nullptr) {}
  void begin(Print* _a, Print* _b = nullptr) { a = _a; b = _b; }

  size_t write(uint8_t c) override {
    size_t n = 0;
    if (a) n += a->write(c);
    if (b) n += b->write(c);
    return n;
  }
  using Print::print;
  using Print::println;

  void printf(const char* fmt, ...) {
    char buf[256];
    va_list ap;
    va_start(ap, fmt);
    ::vsnprintf(buf, sizeof(buf), fmt, ap);  // <-- note o "::"
    va_end(ap);
    print(buf);
  }

private:
  Print* a;
  Print* b;
};

extern TeeLogger LOG;

#define LOGF(...) do { LOG.printf(__VA_ARGS__); } while(0)

main.cpp
#include "main.h"
#include "LedControl.h"
#include "LCDInterface.h"
#include "KeypadHandler.h"
#include "EEPROMHandler.h"
#include "WiFiConfig.h"
#include "MqttHandler.h"
#include "LockControl.h"
#include "PasswordLogic.h"

#include "Log.h"
#include "OledLog.h"

void setup() {
  Serial.begin(115200);

  // Configura o OLED
  oledlog_setup();
  
  // Tee dos logs: Serial + OLED
  LOG.begin(&Serial, &OLED_TERM);
  LOG.println("Logger: Serial + OLED");

  // Resto do setup
  setupLeds();
  setupLcd();
  setupEeprom();
  lock_init(true);
  password_init();

  wifi_setup_nonblocking();
  mqtt_setup();
}

void loop() {
  oledlog_tick();  // Atualiza o OLED com log e Wi-Fi
  
  wifi_tick();
  mqtt_tick();

  char k = lerTecla();
  if (k) password_onKey(k);

  verificarTimeoutMensagem();
}


main.h
// src/main.h
#ifndef MAIN_H
#define MAIN_H

#include <Arduino.h>

extern bool trancaAberta;

#endif

MqttHandler.cpp
#include "MqttHandler.h"
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include "main.h"
#include "LedControl.h"
#include "LCDInterface.h"
#include "secrets.h"

#include "Log.h"

// Credenciais
static const char* MQTT_BROKER = SECRET_MQTT_BROKER;
static const int   MQTT_PORT   = SECRET_MQTT_PORT;
static const char* MQTT_USER   = SECRET_MQTT_USER;
static const char* MQTT_PASS   = SECRET_MQTT_PASS;

// T√≥picos
static const char* MQTT_TOPIC_COMMANDS = "fechadura/comandos";
static const char* MQTT_TOPIC_STATE    = "fechadura/estado";

static WiFiClientSecure espClient;
static PubSubClient client(espClient);

// Publica√ß√£o pendente quando offline
static bool publishPending = false;

// Backoff de reconex√£o
static unsigned long lastMqttAttempt = 0;
static const unsigned long MQTT_RETRY_MS = 3000;

static void mqtt_on_message(char* topic, byte* payload, unsigned int length) {
  LOGF("[MQTT] RX topic=%s len=%u\n", topic, length);

  StaticJsonDocument<128> doc;
  DeserializationError err = deserializeJson(doc, payload, length);
  if (err) {
    LOGF("[MQTT] JSON inv√°lido: %s\n", err.c_str());
    return;
  }

  const char* command = doc["command"];
  if (command && strcmp(command, "toggle") == 0) {
    trancaAberta = !trancaAberta;
    atualizarLeds(trancaAberta);
    if (trancaAberta) exibirAcessoLiberado();
    else              exibirTrancado();

    // confirma novo estado
    publish_current_state();
  }
}

void publish_current_state() {
  // Monta JSON { "tranca_aberta": <bool> }
  StaticJsonDocument<64> doc;
  doc["tranca_aberta"] = trancaAberta;

  char buf[64];
  size_t n = serializeJson(doc, buf, sizeof(buf));

  if (client.connected()) {
    bool ok = client.publish(
      MQTT_TOPIC_STATE,
      reinterpret_cast<const uint8_t*>(buf),
      static_cast<unsigned int>(n),
      true
    );// retained
    LOGF("[MQTT] publish estado '%s': %s\n", buf, ok ? "OK" : "FAIL");
    if (!ok) publishPending = true;
  } else {
    publishPending = true; // envia quando reconectar
  }
}

static void mqtt_connect_once() {
  if (client.connected()) return;
  if (WiFi.status() != WL_CONNECTED) return;

  String cid = "esp32-fechadura-" + WiFi.macAddress();
  if (client.connect(cid.c_str(), MQTT_USER, MQTT_PASS)) {
    LOG.println("[MQTT] conectado!");
    client.subscribe(MQTT_TOPIC_COMMANDS);

    // publica retained na conex√£o (ou o que ficou pendente)
    if (publishPending) {
      publishPending = false;
      publish_current_state();
    } else {
      publish_current_state();
    }
  } else {
    LOGF("[MQTT] falhou rc=%d\n", client.state());
  }
}

void mqtt_setup() {
  espClient.setInsecure();               // TLS sem verifica√ß√£o de CA
  client.setServer(MQTT_BROKER, MQTT_PORT);
  client.setCallback(mqtt_on_message);
}

void mqtt_tick() {
  if (!client.connected()) {
    unsigned long now = millis();
    if (now - lastMqttAttempt >= MQTT_RETRY_MS) {
      lastMqttAttempt = now;
      mqtt_connect_once();
    }
    return;
  }
  client.loop();
}

MqttHandler.h
// src/MqttHandler.h
#ifndef MQTTHANDLER_H
#define MQTTHANDLER_H

// Inicializa cliente e configura callbacks/servidor
void mqtt_setup();

// Avan√ßa a FSM do MQTT (reconex√£o, loop, etc.). Chamar em loop()
void mqtt_tick();

// Publica o estado atual (usa retained). Se offline, marca como pendente
void publish_current_state();

#endif

OledLog.cpp
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "OledTerminal.h"
#include "OledLog.h"
#include <WiFi.h>  // Necess√°rio para acessar o WiFi

Adafruit_SSD1306 OLED_DISPLAY(128, 64, &Wire, -1);
OledTerminal OLED_TERM(&OLED_DISPLAY);

void oledlog_setup() {
  Wire.begin(OLED_SDA, OLED_SCL);
  if (!OLED_DISPLAY.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)) {
    return; // segue sem OLED
  }
  OLED_TERM.begin();
  OLED_TERM.println("OLED log pronto");
}

// Desenha o sinal de Wi-Fi no canto superior direito com barras crescentes
void desenharSinalWifi() {
  long rssi = WiFi.RSSI();
  int signalLevel = 0;

  if (rssi >= -50) signalLevel = 4;
  else if (rssi >= -60) signalLevel = 3;
  else if (rssi >= -70) signalLevel = 2;
  else if (rssi >= -80) signalLevel = 1;
  else signalLevel = 0;

  const int iconBaseX = 108;
  const int iconBaseY = 10;
  const int barWidth = 3;
  const int barGap = 1;
  int barHeights[] = { 2, 4, 6, 8, 10 };

  // CORRE√á√ÉO AQUI: Era SSD136_BLACK, agora √© SSD1306_BLACK
  OLED_DISPLAY.fillRect(iconBaseX, 0, 128 - iconBaseX, iconBaseY + 1, SSD1306_BLACK);

  for (int i = 0; i < 5; i++) {
    if (i <= signalLevel) {
      int currentBarX = iconBaseX + (i * (barWidth + barGap));
      OLED_DISPLAY.fillRect(currentBarX, iconBaseY - barHeights[i], barWidth, barHeights[i], SSD1306_WHITE);
    }
  }
}

// Fun√ß√£o que √© chamada a cada loop
void oledlog_tick() {
  // 1. Sua biblioteca de terminal provavelmente desenha o texto e atualiza a tela.
  OLED_TERM.tick();
  // 2. Agora desenhamos o sinal de Wi-Fi no buffer (por cima do que j√° estava l√°).
  desenharSinalWifi();
  // 3. ESSENCIAL: Enviamos o buffer atualizado (com o texto E o √≠cone) para a tela.
  OLED_DISPLAY.display(); 
}

OledLog.h
// OledLog.h
#pragma once
#include <Adafruit_SSD1306.h>
#include "OledTerminal.h"

// pinos e endere√ßo do OLED
#ifndef OLED_SDA
#define OLED_SDA   21
#endif
#ifndef OLED_SCL
#define OLED_SCL   22
#endif
#ifndef OLED_ADDR
#define OLED_ADDR  0x3C   // troque para 0x3D se o scanner mostrar
#endif

// inst√¢ncias globais de display e ‚Äúterminal‚Äù
extern Adafruit_SSD1306 OLED_DISPLAY;
extern OledTerminal      OLED_TERM;

// inicializa Wire + OLED + terminal
void oledlog_setup();
void oledlog_tick();   // << novo

OledTerminal.h
#pragma once
#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Print.h>
#include <stdarg.h>

class OledTerminal : public Print {
public:
  OledTerminal(Adafruit_SSD1306* d, int cols=21, int rows=8)
    : disp(d), COLS(cols), ROWS(rows), col(0), row(0),
      autoscroll(true), lastRedrawMs(0), redrawIntervalMs(80), pending(false)
  {
    buffer = new char[COLS * ROWS];
    clearBuffer();
  }

  ~OledTerminal() { delete [] buffer; }

  void begin() {
    disp->clearDisplay();
    disp->setTextColor(SSD1306_WHITE);
    disp->setTextSize(1);                // 6x8 px/char ‚Üí ~21x8 em 128x64
    redrawNow();                         // desenha 1x
  }

  void clear() {
    clearBuffer();
    col = row = 0;
    redrawSoon();                        // agenda redraw
  }

  void setAutoscroll(bool on) { autoscroll = on; }

  // Chame periodicamente (ex.: a cada loop) para aplicar redraw se necess√°rio
  void tick() {
    if (pending && (millis() - lastRedrawMs >= redrawIntervalMs)) {
      redrawNow();
    }
  }

  // Print API
  size_t write(uint8_t c) override {
    if (c == '\r') return 1;
    if (c == '\n') { newline(); redrawSoon(); return 1; }
    if (col >= COLS) newline();
    cell(row, col) = (char)c;
    col++;
    // n√£o redesenha aqui; deixa para tick()
    redrawSoon();
    return 1;
  }
  using Print::print;
  using Print::println;

  void printf(const char* fmt, ...) {
    char tmp[256];
    va_list ap; va_start(ap, fmt);
    vsnprintf(tmp, sizeof(tmp), fmt, ap);
    va_end(ap);
    print(tmp);          // escreve no buffer
    redrawSoon();        // agenda redraw (tick() executa)
  }

private:
  Adafruit_SSD1306* disp;
  const int COLS, ROWS;
  int col, row;
  bool autoscroll;
  char* buffer; // ROWS x COLS

  unsigned long lastRedrawMs;
  unsigned long redrawIntervalMs; // ~80ms
  bool pending;

  inline char& cell(int r, int c) { return buffer[r*COLS + c]; }

  void clearBuffer() { memset(buffer, ' ', COLS*ROWS); }

  void scrollUp() {
    memmove(buffer, buffer + COLS, COLS*(ROWS-1));
    memset(buffer + COLS*(ROWS-1), ' ', COLS);
  }

  void newline() {
    col = 0;
    if (row < ROWS - 1) row++;
    else if (autoscroll) scrollUp();
  }

  void redrawSoon() { pending = true; }

  void redrawNow() {
    pending = false;
    disp->clearDisplay();
    for (int r = 0; r < ROWS; r++) {
      disp->setCursor(0, r * 8);
      disp->write((const uint8_t*)&cell(r,0), COLS);
    }
    disp->display();
    lastRedrawMs = millis();
  }
};

PasswordLogic.cpp
#include "PasswordLogic.h"
#include "EEPROMHandler.h"
#include "LCDInterface.h"
#include "LockControl.h"
#include "secrets.h"

// buffers e estados s√≥ aqui
static String senhaAtual;
static const String senhaMestra = MASTER_PASSWORD;
static String bufferNormal;
static String bufferProg;
static bool   modoProg = false;

void password_init()
{
  senhaAtual = lerSenhaDaEeprom();
  bufferNormal = "";
  bufferProg   = "";
  modoProg     = false;
  exibirMensagemInicial();
  exibirDigitacaoNormal(bufferNormal);   // limpa a 2¬™ linha
}

static void entrarModoProg()
{
  modoProg = true;
  bufferProg = "";
  exibirModoProgramacao(bufferProg);
}

static void sairModoProg()
{
  modoProg = false;
  bufferProg = "";
  exibirMensagemInicial();
  exibirDigitacaoNormal(bufferNormal); // garante linha limpa ao sair
}

static void tratarNormal(char k)
{
  // backspace no modo normal: usa '*'
  if (k == '*') {
    if (bufferNormal.length() > 0) {
      bufferNormal.remove(bufferNormal.length() - 1);
    }
    exibirDigitacaoNormal(bufferNormal);
    return;
  }

  // ignora '#' no modo normal (sem a√ß√£o)
  if (k == '#') {
    return;
  }

  // acumula a tecla e atualiza m√°scara
  bufferNormal += k;
  exibirDigitacaoNormal(bufferNormal);

  // senha mestra ‚Üí entra programa√ß√£o
  if (bufferNormal.endsWith(senhaMestra)) {
    bufferNormal = "";
    entrarModoProg();
    return;
  }

  // senha normal ‚Üí alterna tranca
  if (bufferNormal.endsWith(senhaAtual)) {
    bufferNormal = "";
    lock_toggle("keypad");        // atualiza LED/LCD
    exibirMensagemInicial();      // volta tela
    exibirDigitacaoNormal(bufferNormal); // limpa m√°scara
  }
}

static void tratarProg(char k)
{
  if (k == '#') {
    if (bufferProg.length() > 0) {
      salvarSenhaNaEeprom(bufferProg);
      senhaAtual = bufferProg;
    }
    sairModoProg();
    return;
  }

  if (k == '*') {
    if (bufferProg.length() > 0) bufferProg.remove(bufferProg.length() - 1);
    exibirModoProgramacao(bufferProg);
    return;
  }

  if (bufferProg.length() < 10) {
    bufferProg += k;
    exibirModoProgramacao(bufferProg);
  }
}

void password_onKey(char k)
{
  if (!k) return;
  if (modoProg) tratarProg(k);
  else          tratarNormal(k);
}

PasswordLogic.h
#ifndef PASSWORDLOGIC_H
#define PASSWORDLOGIC_H

#include <Arduino.h>

void password_init();        // l√™ senha da EEPROM e prepara buffers
void password_onKey(char k); // tratar tecla (normal/programa√ß√£o)

#endif

WiFiConfig.cpp
#include "WiFiConfig.h"
#include <WiFi.h>
#include "secrets.h"
#include "Log.h"

// DESCOMENTE para Wokwi
//#define WOKWI_SIMULATION

#ifdef WOKWI_SIMULATION
  static const char* ssid = "Wokwi-GUEST";
  static const char* pass = "";
#else
  static const char* ssid = SECRET_WIFI_SSID;
  static const char* pass = SECRET_WIFI_PASS;
#endif

enum class WifiState { Idle, Connecting, Connected };
static WifiState st = WifiState::Idle;
static unsigned long lastTry = 0;
static const unsigned long RETRY_MS = 3000;
static bool everPrintIP = false;

void wifi_setup_nonblocking()
{
  WiFi.mode(WIFI_STA);
  st = WifiState::Idle;
  everPrintIP = false;
}

void wifi_tick()
{
  unsigned long now = millis();

  if (st == WifiState::Idle) {
    if (now - lastTry >= 10) {
      lastTry = now;
      WiFi.begin(ssid, pass);
      st = WifiState::Connecting;
      LOGF("[WiFi] Conectando em '%s'...\n", ssid);
    }
    return;
  }

  if (st == WifiState::Connecting) {
    wl_status_t s = WiFi.status();
    if (s == WL_CONNECTED) {
      st = WifiState::Connected;
      if (!everPrintIP) {
        everPrintIP = true;
        LOGF("[WiFi] Conectado, IP=%s\n", WiFi.localIP().toString().c_str());
      }
    } else if (s == WL_CONNECT_FAILED || s == WL_NO_SSID_AVAIL || s == WL_DISCONNECTED) {
      if (now - lastTry >= RETRY_MS) {
        lastTry = now;
        WiFi.disconnect(true);
        WiFi.begin(ssid, pass);
        LOG.println("[WiFi] Re-Conectando...");
      }
    }
    return;
  }

  if (st == WifiState::Connected) {
    if (WiFi.status() != WL_CONNECTED) {
      st = WifiState::Idle; // caiu ‚Üí recome√ßa
      LOG.println("[WiFi] Desconectado.");
    }
  }
}

bool wifi_is_connected()
{
  return WiFi.status() == WL_CONNECTED;
}

WiFiConfig.h
#ifndef WIFICONFIG_H
#define WIFICONFIG_H

void wifi_setup_nonblocking();  // n√£o trava no setup
void wifi_tick();               // chama no loop()
bool wifi_is_connected();

#endif
